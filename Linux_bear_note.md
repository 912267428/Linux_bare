# ARM裸机（IML6ULL）

## 常用寄存器

| 寄存器名称       | 寄存器描述                 | 描述  /  常用位                                              |
| ---------------- | -------------------------- | ------------------------------------------------------------ |
| cpsr             | 程序状态寄存器             | M[4:0]：控制处理器模式<br />I(bit7)：I=1 禁止 IRQ，I=0 使能 IRQ。 <br />F(bit6)：F=1 禁止 FIQ，F=0 使能 FIQ。 |
| lr               | 链接寄存器                 | 存放当前子程序的返回地址                                     |
| GPIOx_DR         | GPIO数据寄存器             | 一个 GPIO 组最大只有 32 个 IO，因此 DR 寄存器中的每个位都对应 一个 GPIO。 |
| GPIOx_GDIR       | GPIO方向寄存器             | 此寄存器用来设置某个 IO 的工作方向，是输入还是输出。         |
| GPIOx_ICR1/2     | GPIO中断控制寄存器         | ICR1用于配置低16个GPIO， ICR2 用于配置高 16 个 GPIO.一个 GPIO 用两个 位，这两个位用来配置中断的触发方式（见开发指南314） |
| GPIOx_IMR        | GPIO中断屏蔽寄存器         | 一个 GPIO 对应一个位，IMR 寄存器用来控制 GPIO 的中断禁止和使能 |
| GPIOx_ISR        | GPIO中断状态寄存器         | 一个 GPIO 对应一个位，只要某个 GPIO 的中断发生，那么 ISR 中相应的位就会被置 1。处理完中断以后，必须清除中断标志位（写1清零） |
| GPIOx_EDFE       | 边沿选择寄存器             | 覆盖 ICR1 和 ICR2 的设置.设1 则为双边沿触发。一位对应一个GPIO |
| CCM_CCGRx        | 外 设 时 钟 使 能 寄 存 器 | 一般设置全F即可                                              |
| CCSR             | CCM时钟切换寄存器          | 设置系统主频时用到                                           |
| MIDR             | 主 ID 寄存器               | cp15协处理器中的寄存器c0的，主要记录内核信息                 |
| SCTLR            | 系统控制寄存器             | cp15协处理器中的寄存器c1中<br />bit13位为中断向量表基地址选择位，其他为还有I/D Cache 使能位、分支预测使能位、MMU 使能位等等。 |
| VBAR             | 向量表基地址寄存器         | cp15协处理器中的寄存器c12中<br />设置中断向量表偏移的时候就需要 将新的中断向量表基地址写入 VBAR 中 |
| CBAR             |                            | cp15协处理器中的寄存器c15中<br />GIC 的基地址就保存在 CBAR 中，可以通过读取CBAR的值得到 GIC 基地址 |
| GICD_ISENABLERn  |                            | 外部中断使能                                                 |
| GICD_ ICENABLERn |                            | 外部中断禁止                                                 |
| GICC_IAR         |                            | GICC_IAR 保存着当前发生中断的中断号，GIC的CPU接口端基地址加0X0C就是GICC_IAR寄存器 |
| GICC_EOIR        |                            | 当一个中断处理完成以后必 须向 GICC_EOIR 寄存器写入其中断号表示中断处理完成。地址为：CPU接口端基地址+0x10 |
| GICC_PMR         |                            | 决定使用几级优先 级<br />只有低8位有效，最多可以设置256个优先级，我们需要设置32个优先级，GICC_PMR 要设置为 0b11111000=0xF8 |
| GICC_BPR         |                            | 设置抢占优先级和子优先级各占多少位<br />低三位有效，一般直接设置位010 |
| GICD_IPRIORITYR  |                            | 共有512个，用来设置某个中断 ID 的中断优先级                  |



## Cortex-A7 MPCore

### Cortex-A 处理器运行模型

| 模式            | 描述                                                     |
| --------------- | -------------------------------------------------------- |
| User(USR)       | 用户模式，非特权模式，大部分程序运行的时候就处于此模式。 |
| FIQ             | 快速中断模式，进入 FIQ 中断异常                          |
| IRQ             | 一般中断模式。                                           |
| Supervisor(SVC) | 超级管理员模式，特权模式，供操作系统使用。               |
| Monitor(MON)    | 监视模式？这个模式用于安全扩展模式。                     |
| Abort(ABT)      | 数据访问终止模式，用于虚拟存储以及存储保护。             |
| Hyp(HYP)        | 超级监视模式？用于虚拟化扩展。                           |
| Undef(UND)      | 未定义指令终止模式。                                     |
| System(SYS)     | 系统模式，用于运行特权级的操作系统任务                   |

### Cortex-A 寄存器组

![image-20230907010037720](Image\1.png)

前面提到的每一种运行模式都有一组与之对应的寄存器组，这些寄存器中，有些是所有模式所共用的同一个物理寄存器，有一些是各模式自己所独立拥有的

![image-20230907010210012](Image\2.png)

#### 通用寄存器

R0~R15 就是通用寄存器，通用寄存器可以分为以下三类：

1. 未备份寄存器，即 R0~R7。
2. 备份寄存器，即 R8~R14。
3. 程序计数器 PC，即 R15。  R15 (PC)值 = 当前执行的程序位置 + 8 个字节

#### CPSR  程序状态寄存器

所有的处理器模式都共用一个 CPSR 物理寄存器，因此 CPSR 可以在任何模式下被访问。CPSR 是当前程序状态寄存器，该寄存器包含了条件标志位、中断禁止位、当前处理器模式标志 等一些状态位以及一些控制位。bit[4-0]是处理器模式控制位. 其他位见开发指南**293**页

## ARM汇编基本语法

### GNU 汇编语法

GNU 汇编语法适用于所有的架构，并不是 ARM 独享的，GNU 汇编由一系列的语句组成， 每行一条语句，每条语句有三个可选部分，如下：

```
label：instruction @ comment
```

**label** 即标号，表示地址位置，有些指令前面可能会有标号，这样就可以通过这个标号得到 指令的地址，标号也可以用来表示数据地址。注意 label 后面的“：”，任何以“：”结尾的标识 符都会被识别为一个标号。
**instruction** 即指令，也就是汇编指令或伪指令。
**comment** 就是注释内容。

#### 伪操作

用户可以使用.section 伪操作来定义一个段，汇编系统预定义了一些段名：

- .text 表示代码段。
- .data 初始化的数据段。
- .bss 未初始化的数据段。
- rodata 只读数据段。

汇编程序的默认入口标号是_start，不过我们也可以在链接脚本中使用 ENTRY 来指明其它 的入口点。常见的伪操作有：

- .byte 定义单字节数据，比如.byte 0x12。 

- .short 定义双字节数据，比如.short 0x1234。

-  .long 定义一个 4 字节数据，比如.long 0x12345678。 

- .equ 赋值语句，格式为：.equ 变量名，表达式，比如.equ num, 0x12，表示 num=0x12。

-  .align 数据字节对齐，比如：.align 4 表示 4 字节对齐。

-  .end 表示源文件结束。 

- .global 定义一个全局符号，格式为：.global symbol，比如：.global _start。

#### 常用汇编指令

| 指令                   | 描述                                                         |
| ---------------------- | ------------------------------------------------------------ |
| MOV R0，R1             | 将 R1 里面的数据复制到 R0 中。(后面的寄存器可以换成立即数前加#) |
| MRS R0, CPSR           | 将特殊寄存器 CPSR 里面的数据复制到 R0 中。                   |
| MSR CPSR, R0           | 将 R1 里面的数据复制到特殊寄存器 CPSR 里中。                 |
| LDR Rd, [Rn , #offset] | 从存储器 Rn+offset 的位置读取数据存放到 Rd 中。（LDR 加载立即数的时候要使用“=”，而不是“#”） |
| STR Rd, [Rn, #offset]  | 将 Rd 中的数据写入到存储器中的 Rn+offset 位置。              |
| PUSH <reg list>        | 将寄存器列表存入栈中。                                       |
| POP <reg list>         | 从栈中恢复寄存器列表。                                       |
| B <label>              | 跳转到 label                                                 |
| BX <Rm>                | 间接跳转，跳转到存放于 Rm 中的地址处，并且切换指令集         |
| BL <label>             | 跳转到标号地址，并将返回地址保存在 LR 中。                   |
| BLX <Rm>               | 结合 BX 和 BL 的特点，跳转到 Rm 指定的地址，并将返回地 址保存在 LR 中，切换指令集。 |

##### 算术运算指令

| 指令               | 计算公式                | 备注                         |
| ------------------ | ----------------------- | ---------------------------- |
| ADD Rd, Rn, Rm     | Rd = Rn + Rm            |                              |
| ADD Rd, Rn, #immed | Rd = Rn + #immed        | 加法运算，指令为 ADD         |
| ADC Rd, Rn, Rm     | Rd = Rn + Rm + 进位     |                              |
| ADC Rd, Rn, #immed | Rd = Rn + #immed +进位  | 带进位的加法运算，指令为 ADC |
| SUB Rd, Rn, Rm     | Rd = Rn – Rm            |                              |
| SUB Rd, #immed     | Rd = Rd - #immed        |                              |
| SUB Rd, Rn, #immed | Rd = Rn - #immed        | 减法                         |
| SBC Rd, Rn, #immed | Rd = Rn - #immed – 借位 |                              |
| SBC Rd, Rn ,Rm     | Rd = Rn – Rm – 借位     | 带借位的减法                 |
| MUL Rd, Rn, Rm     | Rd = Rn * Rm            | 乘法(32 位)                  |
| UDIV Rd, Rn, Rm    | Rd = Rn / Rm            | 无符号除法                   |
| SDIV Rd, Rn, Rm    | Rd = Rn / Rm            | 有符号除法                   |

##### 逻辑运算指令

| 指令               | 计算公式            | 备注     |
| ------------------ | ------------------- | -------- |
| AND Rd, Rn         | Rd = Rd &Rn         |          |
| AND Rd, Rn, #immed | Rd = Rn &#immed     |          |
| AND Rd, Rn, Rm     | Rd = Rn & Rm        | 按位与   |
| ORR Rd, Rn         | Rd = Rd \| Rn       |          |
| ORR Rd, Rn, #immed | Rd = Rn \| #immed   |          |
| ORR Rd, Rn, Rm     | Rd = Rn \| Rm       | 按位或   |
| BIC Rd, Rn         | Rd = Rd & (~Rn)     |          |
| BIC Rd, Rn, #immed | Rd = Rn & (~#immed) |          |
| BIC Rd, Rn , Rm    | Rd = Rn & (~Rm)     | 位清除   |
| ORN Rd, Rn, #immed | Rd = Rn \| (#immed) |          |
| ORN Rd, Rn, Rm     | Rd = Rn \| (Rm)     | 按位或非 |
| EOR Rd, Rn         | Rd = Rd ^ Rn        |          |
| EOR Rd, Rn, #immed | Rd = Rn ^ #immed    |          |
| EOR Rd, Rn, Rm     | Rd = Rn ^ Rm        | 按位异或 |

## I.MX6ULL IO初始化

1. 使能时钟，CCGR0~CCGR6这7个寄存器控制着6ULL所有外设时钟的使能。为了简单，设置CCGR0~CCGR6这7个寄存器全部为0XFFFFFFFF，相当于使能所有外设时钟。
2. IO复用，将寄存器IOMUXC_SW_**MUX**_CTL_PAD_GPIO1_IO03的bit3~0设置为0101=5，这样GPIO1_IO03就复用为GPIO。IO复用寄存器详情见参考手册
3. 寄存器IOMUXC_SW_**PAD**_CTL_PAD_GPIO1_IO03是设置GPIO1_IO03的电气属性。包括压摆率、速度、驱动能力、开漏、上下拉等。
4. 配置GPIO功能，设置输入输出。设置GPIO1_DR寄存器bit3为1，也就是设置为输出模式。设置GPIO1_DR寄存器的bit3，为1表示输出高电平，为0表示输出低电平。

## C语言环境搭建

1. 设置处理器模式为SVC模式。设置CPSR寄存器的bit4-0，也就是M[4:0]为10011=0X13。读写状态寄存器需要用到MRS和MSR指令。
2. 设置SP指针。Sp可以指向内部RAM，也可以指向DDR，我们将其指向DDR。512MB的范围0x80000000~0x9FFFFFFF。栈大小，0x200000=2MB。处理器栈增长方式，对于A7而言是向下增长的。设置sp指向0x80200000。
3. 跳转到C语言
   使用b指令，跳转到C语言函数，比如main函数。

## 主频和时钟配置

默认配置下 I.MX6U 工作频率为 396MHz。但是 I.MX6U 系列标准的工作频率为 528MHz，有些 型号甚至可以工作到 696MHz。

I.MX6U-ALPHA 开发板的系统时钟来源于两部分：32.768KHz 和 24MHz 的晶振，其中 32.768KHz 晶振是 I.MX6U 的 RTC 时钟源，24MHz 晶振是 I.MX6U 内核 和其它外设的时钟源

I.MX6U 的外设有很多，不同的外设时钟源不同，NXP 将这些外设的时钟源进行了分组， 一共有 7 组，这 7 组时钟源都是从 24MHz 晶振 PLL 而来的，因此也叫做 7 组 PLL

| PLL             | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| ARM_PLL（PLL1） | 供 ARM 内核使用的                                            |
| 528_PLL(PLL2)   | 也叫做 System_PLL，此路 PLL 是固定的 22 倍频，不可编程修改。此 PLL 分出了 4 路 PFD，分别为：PLL2_PFD0~PLL2_PFD3，这 4 路 PFD 和 528_PLL 共同作为其它很多外设的根时钟源。 |
| USB1_PLL(PLL3)  | 主要用于 USBPHY，此 PLL 也有四路 PFD，为： PLL3_PFD0~PLL3_PFD3，USB1_PLL 是固定的 20 倍频，因此 USB1_PLL=24MHz *20=480MHz。 |
| USB2_PLL(PLL7） | 给USB2PHY 使用的。此路PLL固定为20倍频，因此也是480MHz。      |
| ENET_PLL(PLL6)  | 固定为 20+5/6 倍频，因此 ENET_PLL=24MHz * (20+5/6)  = 500MHz。用于生成网络所需的时钟，可以在此 PLL 的基础上生成 25/50/100/125MHz 的网络时钟。 |
| VIDEO_PLL(PLL5) | 用于显示相关的外设，比如 LCD。此路 PLL 的倍频可以 调整，PLL 的输出范围在 650MHz~1300MHz。可选 1/2/4/8/16 分频。 |
| AUDIO_PLL(PLL4) | 用于音频相关的外设，此路 PLL 的倍频可以调整此路 PLL 的倍频可以调整，PLL 的输出范围同样也是 650MHz~1300MHz。可选 1/2/4 分频。 |

时钟数见参考文档410

### 内核时钟设置

1. 内核时钟源来自于 PLL1，假如此时 PLL1 为 996MHz。
2. 通过寄存器 CCM_CACRR 的 ARM_PODF 位对 PLL1 进行分频，可选择 1/2/4/8 分频， 假如我们选择 2 分频，那么经过分频以后的时钟频率是 996/2=498MHz。
3. 经过第②步 2 分频以后的 498MHz 就是 ARM 的内核时钟，也就是 I.MX6U 的主频。
4. 假如我们要设置内核主频为 528MHz，那么 PLL1 可以设置为 1056MHz，寄存器 CCM_CACRR 的 ARM_PODF 位设置为 2 分频即可。同理，如果要将主频设 置为 696MHz，那么 PLL1 就可以设置为 696MHz，CCM_CACRR 的 ARM_PODF 设置为 1 分 频即可。

具体步骤

1. 设置寄存器 CCSR 的 STEP_SEL 位，设置 step_clk 的时钟源为 24M 的晶振。
2. 设置寄存器 CCSR 的 PLL1_SW_CLK_SEL 位，设置 pll1_sw_clk 的时钟源为 step_clk=24MHz，通过这一步我们就将 I.MX6U 的主频先设置为 24MHz，直接来自于外部的 24M 晶振。
3. 设置寄存器 CCM_ANALOG_PLL_ARMn，将 pll1_main_clk(PLL1)设置为 1056MHz。
4. 设置寄存器 CCSR 的 PLL1_SW_CLK_SEL 位，重新将 pll1_sw_clk 的时钟源切换回 pll1_main_clk，切换回来以后的 pll1_sw_clk 就等于 1056MHz。
5. 最后设置寄存器 CCM_CACRR 的 ARM_PODF 为 2 分频，I.MX6U 的内核主频就为 1056/2=528MHz。

见参考手册415

![image-20230907133130276](Image\3.png)

## i.MX6ULL中断

### 中断向量表

Cortex-A中断向量表有8个中断，其中重点关注IRQ。Cortex-A的中断向量表需要用户自己去定义。

| 向量地址 | 中断类型                              | 中断模式                  | 介绍                                                         |
| -------- | ------------------------------------- | ------------------------- | ------------------------------------------------------------ |
| 0X00     | 复位中断(Rest)                        | 特权模式(SVC)             | CPU 复位以后就会进入复位中断，我们可以在复位中断服务函数里面 做一些初始化工作，比如初始化 SP 指针、DDR 等等。 |
| 0X04     | 未定义指令中断(Undefined Instruction) | 未定义指令中止模式(Undef) | 如果指令不能识别的话就会产生此中断。                         |
| 0X08     | 软中断(Software Interrupt,SWI)        | 特权模式(SVC)             | 由 SWI 指令引起的中断，Linux 的系统调用会用 SWI 指令来引起软中断，通过软中断来陷入到内核空间。 |
| 0X0C     | 指令预取中止中断(Prefetch Abort)      | 中止模式                  | 预取指令的出错的时候会产生此中断。                           |
| 0X10     | 数据访问中止中断(Data Abort)          | 中止模式                  | 访问数据出错的时候会产生此中断。                             |
| 0X14     | 未使用(Not Used)                      | 未使用                    | -                                                            |
| 0X18     | IRQ 中断(IRQ Interrupt)               | 外部中断模式(IRQ)         | 芯片内部的外设中断都会引起此 中断的发生。                    |
| 0X1C     | FIQ 中断(FIQ Interrupt)               | 快速中断模式(FIQ)         | 快速中断，如果需要快速处理中断的话就可以使用此中断。         |

Cortex-A内核于CortexB内核不同，没有将所有的中断列举到中断向量表。Cortex-A内核的中断向量表相当于给中断分了几个大类。比如CPU的所有外部中断都属于IRQ中断，当任意一个外部中断发生的时候都会触发 IRQ 中断。如果触发了IRQ中断，只要在 IRQ 中断服 务函数里面就可以读取指定的寄存器来判断发生的具体是什么中断，进而根据具体的中断做出 相应的处理。

### 中断向量偏移

我们的裸机历程都是从0X87800000开始的，因此要设置中断向量偏移。

### GIC控制器

GIC 是 ARM 公司给 Cortex-A/R 内核提供的一个中断控制器，类似 Cortex-M 内核中的 NVIC。GIC V2 是给 ARMv7-A 架构使用的，比如 Cortex-A7、Cortex-A9、Cortex-A15 等， V3 和 V4 是给 ARMv8-A/R 架构使用的，也就是 64 位芯片使用的。

GIC V2 最多支持 8 个核。ARM 会根据 GIC 版本的不同研发 出不同的 IP 核，那些半导体厂商直接购买对应的 IP 核即可，比如 ARM 针对 GIC V2 就开发出 了 GIC400 这个中断控制器 IP 核。**当 GIC 接收到外部中断信号以后就会报给 ARM 内核**，但是 ARM 内核只提供了四个信号给 GIC 来汇报中断情况：VFIQ、VIRQ、FIQ 和 IRQ，他们之间的 关系如图所示：

![image-20230907154253727](Image\4.png)

最终就只通过四个信号 报给 ARM 内核

1. VFIQ:虚拟快速 FIQ。
2. VIRQ:虚拟外部 IRQ。
3. FIQ:快速中断 IRQ。
4. IRQ:外部中断 IRQ。
   **目前只讲IRQ**

**GICV2总体框图：**

![image-20230907154617159](Image\5.png)

左侧部分就是中断源，中间部分就是 GIC 控制器，最右侧就是中断控制器向 处理器内核发送中断信息。GIC 将众多的中断源分为 分为三类：

1. SPI(Shared Peripheral Interrupt),共享中断，顾名思义，所有 Core 共享的中断，这个是最 常见的，那些外部中断都属于 SPI 中断。比如按键中断、串口 中断等等，这些中断所有的 Core 都可以处理，不限定特定 Core。
2. PPI(Private Peripheral Interrupt)，私有中断，我们说了 GIC 是支持多核的，每个核肯定 有自己独有的中断。这些独有的中断肯定是要指定的核心处理，因此这些中断就叫做私有中断。
3. SGI(Software-generated Interrupt)，软件中断，由软件触发引起的中断，通过向寄存器 GICD_SGIR 写入数据来触发，系统会使用 SGI 中断来完成多核之间的通信。

#### 中断ID

前面我们知道Cortex-A系列的中断向量表只有7个中断，所有的外部中断都会触发IRQ中断，那么为了在IRQ中断服务函数中确定是那个外设触发了中断，这里引入**中断ID**。

区分这些不同的中断源给他们分配一个唯一 ID，这些 ID 就是 中断 ID。

每个CPU最多支持 1020 个中断 ID，中断 ID 号为 ID0~ID1019。

这1020个ID包含了PPI、SPI、和SGI。

- ID0~ID15：分配给了SGI
- ID16~ID31：分配给了PPI
- ID32~ID1019：这988个中断ID分配给SPI。

像 GPIO 中断、串口中断等这些外部中断 ，至于 具体到某个 ID 对应哪个中断那就由半导体厂商根据实际情况去定义了。比如 I.MX6U 的总共 使用了 128 个中断 ID，加上前面属于 PPI 和 SGI 的 32 个 ID，I.MX6U 的中断源共有 128+32=160 个

**这 128 个中断 ID 对应的中断在《I.MX6ULL 参考手册》的“3.2 CortexA7 interrupts”小节**

#### GIC逻辑分块

GIC 架构分为了两个逻辑块：Distributor 和 CPU Interface，也就是分发器端和 CPU 接口端。

##### Distributor(分发器端)

分发器端：负责处理各个中断事件的分发问 题，也就是中断事件应该发送到哪个 CPU Interface 上去。分发器收集所有的中断源，可以控制 每个中断的优先级，它总是将优先级最高的中断事件发送到 CPU 接口端。分发器端要做的主要 工作如下：

1. 全局中断使能控制。
2. 控制每一个中断的使能或者关闭。
3. 设置每个中断的优先级。
4. 设置每个中断的目标处理器列表。
5. 设置每个外部中断的触发模式：电平触发或边沿触发。
6. 设置每个中断属于组 0 还是组 1。

##### CPU Interface(CPU 接口端)

CPU 接口端听名字就知道是和 CPU Core 相连接的，因此在 图 17.1.3.2 中每个 CPU Core 都可以在 GIC 中找到一个与之对应的 CPU Interface。CPU 接口端 就是分发器和 CPU Core 之间的桥梁，CPU 接口端主要工作如下：

1. 使能或者关闭发送到 CPU Core 的中断请求信号。
2. 应答中断。
3. 通知中断处理完成。
4. 设置优先级掩码，通过掩码来设置哪些中断不需要上报给 CPU Core。
5. 定义抢占策略。
6. 、当多个中断到来的时候，选择优先级最高的中断通知给 CPU Core。

Distributor(分发器端)，相对于 GIC 基地址偏移为 **0X1000**，因此我们获 取到 GIC 基地址以后只需要加上 0X1000 即可访问 GIC 分发器端寄存器。
CPU Interface(CPU 接口端)，相对于 GIC 基地址偏移为 **0X2000**，因此我们获 取到 GIC 基地址以后只需要加上 0X2000 即可访问 GIC 的 CPU 接口段寄存器。

### cp15协处理器

CP15 协处理器一般用于存储系统管理，但是在中断中也会使用到，CP15 协处理器一共有 16 个 32 位寄存器。CP15 协处理器的访问通过如下另个指令完成：

**MRC**: 将 CP15 协处理器中的寄存器数据读到 ARM 寄存器中。
**MCR**: 将 ARM 寄存器的数据写入到 CP15 协处理器寄存器中。

MRC 就是读 CP15 寄存器，MCR 就是写 CP15 寄存器，MCR 指令格式如下：

```
MCR{cond} p15, <opc1>, <Rt>, <CRn>, <CRm>, <opc2>
```

- **cond**:指令执行的条件码，如果忽略的话就表示无条件执行。
- **opc1**：协处理器要执行的操作码。
- **Rt**：ARM 源寄存器，要写入到 CP15 寄存器的数据就保存在此寄存器中。
- **CRn**：CP15 协处理器的目标寄存器。
- **CRm**：协处理器中附加的目标寄存器或者源操作数寄存器，如果不需要附加信息就将 CRm 设置为 C0，否则结果不可预测。
- **opc2**：可选的协处理器特定操作码，当不需要的时候要设置为 0。

CP15 协处理器有 16 个 32 位寄存器，c0~c15，目前先看 c0、c1、c12 和 c15 这四个寄 存器。

#### c0寄存器

指令中的 CRn、opc1、CRm 和 opc2 通过不同的搭配，其得到的寄存器含义是 不同的。

详情见开发指南439页

当 MRC/MCR 指令中的 CRn=c0，opc1=0，CRm=c0，opc2=0 的时候就表示 此时的 c0 就是 MIDR 寄存器，也就是主 ID 寄存器，这个也是 c0 的基本作用。对于 Cortex-A7 内核来说，c0 作为 MDIR 寄存器的时候其含义如图 17.1.4.2 所示：详情见开发指南439页，各位的含义：基本是内核的信息啥的。

#### c1寄存器

指令中不同的搭配得到不同的寄存器：

![image-20230907161001365](Image\6.png)

CRn=c1，opc1=0，CRm=c0，opc2=0 的时候就表示 此时的 c1 就是 SCTLR 寄存器，也就是系统控制寄存器，这个是 c1 的基本作用。SCTLR 寄存 器主要是完成控制功能的，比如使能或者禁止 MMU、I/D Cache 等，c1 作为 SCTLR 寄存器的时 候其含义所示：

![image-20230907161046847](Image\7.png)

关于中断中一定要用到的位是**bit13位**，中断向量表基地址选择位，为 0 的话中断向量表基地址为 0X00000000，软件可 以使用 VBAR 来重映射此基地址，也就是中断向量表重定位。为 1 的话中断向量表基地址为 0XFFFF0000，此基地址不能被重映射。

#### c12寄存器

![image-20230907161343025](Image\8.png)

CRn=c12，opc1=0，CRm=c0，opc2=0 的时候就表 示此时 c12 为 VBAR 寄存器，也就是向量表基地址寄存器。在设置中断向量表偏移的时候需要将新的中断向量表基地址写入 VBAR 中。

#### c15寄存器

![image-20230907161653605](Image\9.png)

对于cp15协处理器的CBAR寄存器，我们在中断控制中需要使用，因为GIC 的基地址就保存在 CBAR 中。可以通过如下命令获取到 GIC 基地址：

```
MRC p15, 4, r1, c15, c0, 0 ; 获取 GIC 基础地址，基地址保存在 r1 中。
ADD r1, r1, #0X2000 ;GIC 基地址加 0X2000 得到 CPU 接口端寄存器起始地址
LDR r0, [r1, #0XC] ;读取 CPU 接口端起始地址+0XC 处的寄存器值，也就是寄存器GIC_IAR 的值

```

简单总结一下，通过 c0 寄存器可以获取到处理器内核信息；通过 c1 寄存器可以使能或禁止 MMU、I/D Cache 等；通过 c12 寄存器可以设置中断 向量偏移；通过 c15 寄存器可以获取 GIC 基地址。

### 中断使能

中断使能包括两部分，一个是 IRQ 或者 FIQ 总中断使能，另一个就是 ID0~ID1019 这 1020 个中断源的使能。

#### IRQ 和 FIQ 总中断使能

IRQ 和 FIQ 分别是外部中断和快速中断的总开关，就类似家里买的进户总电闸，然后 ID0~ID1019 这 1020 个中断源就类似家里面的各个电器开关。

寄存器 CPSR 的 I=1 禁止 IRQ，当 I（第7位）=0 使 能 IRQ；F（第6位）=1 禁止 FIQ，F=0 使能 FIQ。其实还有更简单的指令来完成 IRQ 或者 FIQ 的使能和 禁止

| 指令    | 描述            |
| ------- | --------------- |
| cpsid i | 禁止 IRQ 中断。 |
| cpsie i | 使能 IRQ 中断。 |
| cpsid f | 禁止 FIQ 中断。 |
| cpsie f | 使能 FIQ 中断。 |

#### ID0~ID1019 中断使能和禁止

GIC 寄存器 GICD_ISENABLERn 和 GICD_ ICENABLERn 用来完成外部中断的使能和禁 止

对于 Cortex-A7 内核来说中断 ID 只使用了 512 个。一个 bit 控制一个中断 ID 的使能，那么 就需要 512/32=16 个 GICD_ISENABLER 寄存器来完成中断的使能。同理，也需要 16 个 GICD_ICENABLER 寄存器来完成中断的禁止。

其中 GICD_ISENABLER0 的 bit[15:0]对应 ID15~0 的 SGI 中断，GICD_ISENABLER0 的 bit[31:16]对应 ID31~16 的 PPI 中断。剩下的 GICD_ISENABLER1~GICD_ISENABLER15 就是控制 SPI 中断的。

### 中断优先级设置

Cortex-A7 的中断优先级也可以分为抢占优先级和子优先级，两者同样是可以配置 的。GIC 控制器最多可以支持 256 个优先级，数字越小，优先级越高

Cortex-A7 选择了 32 个 优先级。在使用中断的时候需要初始化 **GICC_PMR** 寄存器，此寄存器用来决定使用几级优先 级

#### 抢占优先级和子优先级位数设置

抢占优先级和子优先级各占多少位是由寄存器 GICC_BPR 来决定的
GICC_BPR 寄存器的[31:3]都是保留位。所有GICC_BPR 寄存器只有低三位有效

![image-20230907163322958](Image\10.png)

为了简单起见，一般将所有的中断优先级位都配置为抢占优先级，比如 I.MX6U 的优先级 位数为 5(32 个优先级)，所以可以设置 Binary point 为 2，表示 5 个优先级位全部为抢占优先级。

#### 优先级设置

具体要使用某 个中断的时候就可以设置其优先级为 0~31。

某个中断 ID 的中断优先级设置由寄存器GICD_IPRIORITYR来完成

前面说了 Cortex-A7 使用了 512 个中断 ID，每个中断 ID 配有一个优 先级寄存器，所以一共有 512 个 GICD_IPRIORITYR寄存器。如果优先级个数为 32 的话，使用寄存器 GICD_IPRIORITYR的 bit7:4 来设置优先级，也就是说实际的优先级要左移 3 位。比如要设置 ID40 中断的优先级为 5，示例代码如下：

```
GICD_IPRIORITYR[40] = 5 << 3;
```

有关优先级设置的内容就讲解到这里，优先级设置主要有三部分：

1. 设置寄存器 GICC_PMR，配置优先级个数，比如 I.MX6U 支持 32 级优先级。
2. 设置抢占优先级和子优先级位数，一般为了简单起见，会将所有的位数都设置为抢占 优先级。
3. 设置指定中断 ID 的优先级，也就是设置外设优先级。

### 编程注意事项

#### 用汇编变现的start.S中

1. 添加中断向量表，编写复位中断服务函数和IRQ中断服务函数。
2. 复位中断服务函数中的内容：
   - 关闭I,D Cache和MMU。
   - 设置处理器9中工作模式下对应的SP指针。要使用中断那么必须设置IRQ模式下的SP指针。索性直接设置所有模式下的SP指针。
   - 清除bss段。
   - 跳到C函数，也就是main函数
3. IRQ中断服务函数中的内容：
   - 读取CP15的CBAR寄存器。CBAR寄存器保存了GIC控制器的寄存器组首地址
   - GIC寄存器组偏移0x1000~0x1fff为GIC的分发器。0x2000~0x3fff为CPU接口端。意味我们可以访问GIC控制器了！
   - 代码中，R1寄存器吧保存着GIC控制器的CPU接口端基地址。读取CPU接口段的GICC_IAR寄存器的值保存到R0寄存器里面。可以从GICC_IAR的bit9~0读取中断ID，我们读取中断ID的目的就是为了得到对应的中断处理函数。
   - system_irqhandler就是具体的中断处理函数，此函数有一个参数，为GICC_IAR寄存器的值。
   - system_irqhandler处理完具体的中断以后，需要将对应的中断ID值写入到GICC_EOIR寄存器里面。

#### bsp_int.h/c  通用的中断驱动。

- 初始化中断
  - 初始化GIC
  - 初始化中断处理函数表
  - 设置中断向量偏移
- 默认中断处理函数，（在初始化中断处理函数表时将所有外设中断的处理函数设置为默认的中断处理函数）
- 注册中断处理函数
- 具体的中断处理函数

bsp_int通用的中断驱动中有int_init初始化中断函数，在需要使用中断时一定要第一个初始化中断。
还有一个重要的函数就是system_register_irqhandler，这是注册中断处理函数。

#### bsp_GPIO.h/c  通用GPIO驱动中需要添加的内容

1. GPIO中断触发类型枚举，列举了将要初始化的GPIO口的中断类型（不需要中断则指定无即可）
2. GPIO 配置结构体中加入一个中断方式的成员变量
3. 加入GPIO指定IO使能和禁止中断的函数
4. 加入GPIO清除中断标志位函数
5. 加入设置GPIO的中断配置功能函数，在gpio_init中调用
   也就是说在初始化GPIO时只需要在结构体中传入中断类型，该GPIO口中断的设置已经完成

#### bsp_exit.h/c中断驱动内容：

1. exit_init初始化外部中断函数，
   - IO口初始化，
   - 利用GIC_EnableIRQ，使能IO口对应的中断号
   - 编写中断处理函数，并用system_register_irqhandler函数将中断处理函数注册到相应的中断id中。
   - 使能gpio口中断，gpio_enableint(GPIO1, 18);